// Generated by CoffeeScript 1.12.3

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Matthew South
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

(function() {
  var ArgumentFramework, GroundedLabeller, IdealSemantics, Labeller, Labelling, PreferredLabeller, StableSemantics, complement, intersection, isStrictSubset, isSubset, powerset, root, union,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  powerset = function(S) {
    var P, i, j;
    P = [[]];
    for (i in S) {
      for (j in P) {
        P.push(P[j].concat(S[i]));
      }
    }
    return P;
  };

  complement = function(A, B) {
    var el, k, len, results;
    results = [];
    for (k = 0, len = B.length; k < len; k++) {
      el = B[k];
      if (indexOf.call(A, el) < 0) {
        results.push(el);
      }
    }
    return results;
  };

  isSubset = function(A, B) {
    var el, k, len;
    for (k = 0, len = A.length; k < len; k++) {
      el = A[k];
      if (!(indexOf.call(B, el) >= 0)) {
        return false;
      }
    }
    return true;
  };

  isStrictSubset = function(A, B) {
    return isSubset(A, B) && A.length < B.length;
  };

  intersection = function(A, B) {
    var el, k, len, result;
    result = [];
    for (k = 0, len = A.length; k < len; k++) {
      el = A[k];
      if (indexOf.call(B, el) >= 0) {
        result.push(el);
      }
    }
    return result;
  };

  union = function(A, B) {
    var el, k, len, result;
    result = A;
    for (k = 0, len = B.length; k < len; k++) {
      el = B[k];
      if (!(indexOf.call(A, el) >= 0)) {
        result.push(el);
      }
    }
    return result;
  };

  ArgumentFramework = (function() {
    function ArgumentFramework(defeatermap) {
      var arg, defeater, k, l, len, len1, ref, ref1;
      this.defeatermap = defeatermap != null ? defeatermap : {};
      this.argids = Object.keys(this.defeatermap);
      ref = this.argids;
      for (k = 0, len = ref.length; k < len; k++) {
        arg = ref[k];
        if (!Array.isArray(this.defeatermap[arg])) {
          throw new Error("@defeatermap[" + arg + "] isnt an array.  @defeatermap must contain arrays.");
        }
        ref1 = this.defeatermap[arg];
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          defeater = ref1[l];
          if (indexOf.call(this.argids, defeater) < 0) {
            throw new Error("unknown @defeatermap defeater of " + arg + " - " + defeater);
          }
        }
      }
    }

    ArgumentFramework.prototype.isDefeated = function(arg, args, checkParams) {
      var k, len, possibledefeater;
      if (checkParams == null) {
        checkParams = true;
      }
      if (checkParams) {
        this._checkArg(arg);
        this._checkArgs(args);
      }
      for (k = 0, len = args.length; k < len; k++) {
        possibledefeater = args[k];
        if (indexOf.call(this.defeatermap[arg], possibledefeater) >= 0) {
          return true;
        }
      }
      return false;
    };

    ArgumentFramework.prototype.defeatedBy = function(arg, checkParams) {
      var defeated, k, len, ref, results;
      if (checkParams == null) {
        checkParams = true;
      }
      if (checkParams) {
        this._checkArg(arg);
      }
      ref = this.argids;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        defeated = ref[k];
        if (indexOf.call(this.defeatermap[defeated], arg) >= 0) {
          results.push(defeated);
        }
      }
      return results;
    };

    ArgumentFramework.prototype.isConflictFree = function(args, checkParams) {
      var k, len, target;
      if (checkParams == null) {
        checkParams = true;
      }
      if (checkParams) {
        this._checkArgs(args);
      }
      for (k = 0, len = args.length; k < len; k++) {
        target = args[k];
        if (this.isDefeated(target, args)) {
          return false;
        }
      }
      return true;
    };

    ArgumentFramework.prototype.isAcceptable = function(arg, args, checkParams) {
      var defeater, k, len, ref;
      if (checkParams == null) {
        checkParams = true;
      }
      if (checkParams) {
        this._checkArg(arg);
        this._checkArgs(args);
      }
      ref = this.defeatermap[arg];
      for (k = 0, len = ref.length; k < len; k++) {
        defeater = ref[k];
        if (!this.isDefeated(defeater, args)) {
          return false;
        }
      }
      return true;
    };

    ArgumentFramework.prototype.isAdmissible = function(args, checkParams) {
      if (checkParams == null) {
        checkParams = true;
      }
      if (checkParams) {
        this._checkArgs(args);
      }
      return this.isConflictFree(args, false) && args.every((function(_this) {
        return function(arg) {
          return _this.isAcceptable(arg, args, false);
        };
      })(this));
    };

    ArgumentFramework.prototype.isComplete = function(args, checkParams) {
      var k, len, other, ref;
      if (checkParams == null) {
        checkParams = true;
      }
      if (checkParams) {
        this._checkArgs(args);
      }
      ref = complement(args, this.argids);
      for (k = 0, len = ref.length; k < len; k++) {
        other = ref[k];
        if (this.isAcceptable(other, args, false)) {
          return false;
        }
      }
      return this.isAdmissible(args, false);
    };

    ArgumentFramework.prototype.isStable = function(args, checkParams) {
      var k, len, other, ref;
      if (checkParams == null) {
        checkParams = true;
      }
      if (checkParams) {
        this._checkArgs(args);
      }
      ref = complement(args, this.argids);
      for (k = 0, len = ref.length; k < len; k++) {
        other = ref[k];
        if (!this.isDefeated(other, args, false)) {
          return false;
        }
      }
      return this.isConflictFree(args, false);
    };

    ArgumentFramework.prototype.isLegalLabelling = function(labelling) {
      var arg, defeater, k, l, len, len1, len2, len3, len4, len5, m, n, o, ok, p, ref, ref1, ref2, ref3, ref4, ref5;
      if (labelling.complement(this.argids).length !== 0) {
        return false;
      }
      ref = labelling["in"];
      for (k = 0, len = ref.length; k < len; k++) {
        arg = ref[k];
        ref1 = this.defeatermap[arg];
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          defeater = ref1[l];
          if (indexOf.call(labelling.out, defeater) < 0) {
            return false;
          }
        }
      }
      ref2 = labelling.out;
      for (m = 0, len2 = ref2.length; m < len2; m++) {
        arg = ref2[m];
        ok = false;
        ref3 = this.defeatermap[arg];
        for (n = 0, len3 = ref3.length; n < len3; n++) {
          defeater = ref3[n];
          if (indexOf.call(labelling["in"], defeater) >= 0) {
            ok = true;
            break;
          }
        }
        if (!ok) {
          return false;
        }
      }
      ref4 = labelling.undec;
      for (o = 0, len4 = ref4.length; o < len4; o++) {
        arg = ref4[o];
        if (!(this.defeatermap[arg].length > 0)) {
          return false;
        }
        ok = false;
        ref5 = this.defeatermap[arg];
        for (p = 0, len5 = ref5.length; p < len5; p++) {
          defeater = ref5[p];
          if (indexOf.call(labelling["in"], defeater) >= 0) {
            return false;
          }
          if (indexOf.call(labelling.undec, defeater) >= 0) {
            ok = true;
          }
        }
        if (!ok) {
          return false;
        }
      }
      return true;
    };

    ArgumentFramework.prototype._checkArg = function(arg) {
      if (!(indexOf.call(this.argids, arg) >= 0)) {
        throw new Error("unknown arg - " + arg);
      }
    };

    ArgumentFramework.prototype._checkArgs = function(args) {
      var unknown;
      unknown = complement(this.argids, args);
      if (unknown.length > 0) {
        throw new Error("unknown members of args - [" + unknown + "]");
      }
    };

    return ArgumentFramework;

  })();

  Labelling = (function() {
    function Labelling(_in, out, undec) {
      this["in"] = _in != null ? _in : [];
      this.out = out != null ? out : [];
      this.undec = undec != null ? undec : [];
      if (intersection(this["in"], this.out).length > 0) {
        throw new Error('invalid labelling - dup found in in/out');
      }
      if (intersection(this["in"], this.undec).length > 0) {
        throw new Error('invalid labelling - dup found in in/undec');
      }
      if (intersection(this.out, this.undec).length > 0) {
        throw new Error('invalid labelling - dup found in out/undec');
      }
    }

    Labelling.prototype.equals = function(labelling) {
      var arrtest, result;
      arrtest = function(arr1, arr2) {
        return arr1.length === arr2.length && arr1.every(function(el, idx) {
          return arr2[idx] === el;
        });
      };
      result = arrtest(this["in"].sort(), labelling["in"].sort()) && arrtest(this.out.sort(), labelling.out.sort()) && arrtest(this.undec.sort(), labelling.undec.sort());
      return result;
    };

    Labelling.prototype.complement = function(args) {
      return complement(this.undec, complement(this.out, complement(this["in"], args)));
    };

    Labelling.prototype.clone = function() {
      return new Labelling(this["in"].slice(0), this.out.slice(0), this.undec.slice(0));
    };

    Labelling.prototype.illegallyIn = function(af) {
      var arg, k, len, ref, results;
      ref = this["in"];
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        arg = ref[k];
        if (!isSubset(af.defeatermap[arg], this.out)) {
          results.push(arg);
        }
      }
      return results;
    };

    Labelling.prototype.illegallyOut = function(af) {
      var arg, k, len, ref, results;
      ref = this.out;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        arg = ref[k];
        if (intersection(af.defeatermap[arg], this["in"]).length === 0) {
          results.push(arg);
        }
      }
      return results;
    };

    Labelling.prototype.move = function(arg, from, to) {
      var checkLabel;
      checkLabel = function(label) {
        if (!(label === 'in' || label === 'out' || label === 'undec')) {
          throw new Error("unknown label - " + label);
        }
      };
      checkLabel(from);
      checkLabel(to);
      if (!(indexOf.call(this[from], arg) >= 0)) {
        throw new Error("argument " + arg + " doesnt have label " + from);
      }
      this[from].splice(this[from].indexOf(arg), 1);
      this[to].push(arg);
      return this;
    };

    return Labelling;

  })();

  Labeller = (function() {
    function Labeller(af1) {
      this.af = af1;
    }

    Labeller.prototype.extensions = function() {
      var k, labelling, len, ref, results;
      ref = this.labellings();
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        labelling = ref[k];
        results.push(labelling["in"]);
      }
      return results;
    };

    return Labeller;

  })();

  GroundedLabeller = (function(superClass) {
    extend(GroundedLabeller, superClass);

    function GroundedLabeller() {
      return GroundedLabeller.__super__.constructor.apply(this, arguments);
    }

    GroundedLabeller.prototype.labellings = function() {
      var extendinout, labelling;
      labelling = new Labelling();
      extendinout = (function(_this) {
        return function() {
          var added, arg, k, l, len, len1, others;
          others = labelling.complement(_this.af.argids);
          added = [];
          for (k = 0, len = others.length; k < len; k++) {
            arg = others[k];
            if (isSubset(_this.af.defeatermap[arg], labelling.out)) {
              added.push(arg);
              labelling["in"].push(arg);
            }
          }
          if (added.length > 0) {
            others = complement(added, others);
          }
          for (l = 0, len1 = others.length; l < len1; l++) {
            arg = others[l];
            if (_this.af.isDefeated(arg, labelling["in"])) {
              labelling.out.push(arg);
              added.push(arg);
            }
          }
          if (added.length > 0) {
            return extendinout();
          }
        };
      })(this);
      extendinout();
      labelling.undec = labelling.complement(this.af.argids);
      return [labelling];
    };

    return GroundedLabeller;

  })(Labeller);

  PreferredLabeller = (function(superClass) {
    extend(PreferredLabeller, superClass);

    function PreferredLabeller() {
      return PreferredLabeller.__super__.constructor.apply(this, arguments);
    }

    PreferredLabeller.prototype.labellings = function() {
      var candidates, checkIn, findLabellings, transitionLabelling;
      checkIn = (function(_this) {
        return function(labelling) {
          var hasUndecDefeater, illegal, illegals, k, legalDefeaters, legals, len, result;
          hasUndecDefeater = function(arg) {
            var defeater, k, len, ref;
            ref = _this.af.defeatermap[arg];
            for (k = 0, len = ref.length; k < len; k++) {
              defeater = ref[k];
              if (indexOf.call(labelling.undec, defeater) >= 0) {
                return true;
              }
            }
            return false;
          };
          result = {
            superIllegal: [],
            illegal: []
          };
          illegals = labelling.illegallyIn(_this.af);
          legals = complement(illegals, labelling["in"]);
          for (k = 0, len = illegals.length; k < len; k++) {
            illegal = illegals[k];
            legalDefeaters = intersection(_this.af.defeatermap[illegal], legals);
            if (legalDefeaters.length > 0 || hasUndecDefeater(illegal)) {
              result.superIllegal.push(illegal);
            } else {
              result.illegal.push(illegal);
            }
          }
          return result;
        };
      })(this);
      transitionLabelling = (function(_this) {
        return function(labelling, arg) {
          var cloned, defeated, illegallyOut, k, len, ref;
          cloned = labelling.clone();
          cloned.move(arg, 'in', 'out');
          illegallyOut = cloned.illegallyOut(_this.af);
          ref = _this.af.defeatedBy(arg);
          for (k = 0, len = ref.length; k < len; k++) {
            defeated = ref[k];
            if (indexOf.call(illegallyOut, defeated) >= 0) {
              cloned.move(defeated, 'out', 'undec');
            }
          }
          if (indexOf.call(illegallyOut, arg) >= 0 && indexOf.call(cloned.out, arg) >= 0) {
            cloned.move(arg, 'out', 'undec');
          }
          return cloned;
        };
      })(this);
      findLabellings = (function(_this) {
        return function(labelling) {
          var arg, existing, idx, illegals, k, l, len, len1, len2, len3, m, n, ok, ref, results;
          for (k = 0, len = candidates.length; k < len; k++) {
            existing = candidates[k];
            if (isStrictSubset(labelling["in"], existing["in"])) {
              return;
            }
          }
          illegals = checkIn(labelling);
          if (illegals.illegal.length > 0 || illegals.superIllegal.length > 0) {
            if (illegals.superIllegal.length > 0) {
              return findLabellings(transitionLabelling(labelling, illegals.superIllegal[0]));
            } else {
              ref = illegals.illegal;
              results = [];
              for (l = 0, len1 = ref.length; l < len1; l++) {
                arg = ref[l];
                results.push(findLabellings(transitionLabelling(labelling, arg)));
              }
              return results;
            }
          } else {
            for (idx = m = 0, len2 = candidates.length; m < len2; idx = ++m) {
              existing = candidates[idx];
              if (isStrictSubset(existing["in"], labelling["in"])) {
                candidates.splice(idx);
              }
            }
            ok = true;
            for (n = 0, len3 = candidates.length; n < len3; n++) {
              existing = candidates[n];
              if (existing.equals(labelling)) {
                ok = false;
              }
            }
            if (!!ok) {
              candidates.push(labelling);
            }
          }
        };
      })(this);
      candidates = [];
      findLabellings(new Labelling(this.af.argids));
      return candidates;
    };

    return PreferredLabeller;

  })(Labeller);

  StableSemantics = (function(superClass) {
    extend(StableSemantics, superClass);

    function StableSemantics() {
      return StableSemantics.__super__.constructor.apply(this, arguments);
    }

    StableSemantics.prototype.extensions = function() {
      var k, labelling, len, ref, results;
      ref = this.labellings();
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        labelling = ref[k];
        if (labelling.undec.length === 0) {
          results.push(labelling["in"]);
        }
      }
      return results;
    };

    return StableSemantics;

  })(PreferredLabeller);

  IdealSemantics = (function(superClass) {
    extend(IdealSemantics, superClass);

    function IdealSemantics() {
      return IdealSemantics.__super__.constructor.apply(this, arguments);
    }

    IdealSemantics.prototype.extensions = function() {
      var k, l, labelling, len, len1, ref, ref1, result, subset;
      result = this.af.argids;
      ref = this.labellings();
      for (k = 0, len = ref.length; k < len; k++) {
        labelling = ref[k];
        result = intersection(result, labelling["in"]);
      }
      ref1 = powerset(result).sort(function(a, b) {
        return b.length - a.length;
      });
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        subset = ref1[l];
        if (this.af.isAdmissible(subset)) {
          return [subset];
        }
      }
    };

    return IdealSemantics;

  })(PreferredLabeller);

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.ArgumentFramework = ArgumentFramework;

  root.Labelling = Labelling;

  root.GroundedLabeller = GroundedLabeller;

  root.PreferredLabeller = PreferredLabeller;

  root.StableSemantics = StableSemantics;

  root.IdealSemantics = IdealSemantics;

}).call(this);
