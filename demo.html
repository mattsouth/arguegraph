<!doctype html>
<html>
<head>
  <title>Arguegraph :: Basics</title>

  <script type="text/javascript" src="js/vis.min.js"></script>
  <script type="text/javascript" src="js/graphs.js"></script>
  <script type="text/javascript" src="js/arguegraph.js"></script>
  <link href="css/vis.min.css" rel="stylesheet" type="text/css" />

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <style type="text/css">
    #mynetwork {
      height: 400px;
      border: 1px solid lightgray;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="row">
    <h2 class="col-sm-8">Arguegraph :: Basics</h2>
    <h2 class="col-sm-4">
      <div class="pull-right hidden-xs">
        <a class="btn btn-default" href="#" onclick="javascript:down()"> &lt; </a>
        <span class="position"></span>
        <a class="btn btn-default" href="#" onclick="javascript:up()"> &gt; </a>
      </div>
      <div class="visible-xs-block">
        <a class="btn btn-default" href="#" onclick="javascript:down()"> &lt; </a>
        <span class="position"></span>
        <a class="btn btn-default" href="#" onclick="javascript:up()"> &gt; </a>
      </div>
    </h2>
  </div>
  <div class="row">
    <div class="col-xs-12">
      <p>
        A directed graph can be used to represent an adversarial argument
        framework where nodes are arguments and edges are attacks between
        arguments. The arguegraph javascript library allows you to calculate
        the sets of arguments that defend themselves using different algorithms,
        otherwise known as semantics.  This demo allows you to view the results
        of grounded semantics for all the distinct directed graphs with up to
        three nodes.
      </p>
    </div>
  </div>
  <div class="row">
    <div class="col-xs-12">
      <div id="mynetwork"></div>
    </div>
  </div>
  <div class="row">
    <div class="col-xs-12">
      <h4>Grounded Semantics</h4>
      <p>
        Grounded Semantics are the most sceptical.  Nodes/arguments are in the
        grounded extension if they are unattacked or defended by an argument that
        is also in the ground extension. For any network there is only ever one
        ground extension. In this graph yellow nodes represent accepted
        arguments (i.e. in the ground extension) and red nodes are not accepted
        arguments.
      </p>
    </div>
  </div>
</div>
<script type="text/javascript">
  let keys = Object.keys(graphs);
  let index = 0;
  let nodes = new vis.DataSet();
  let edges = new vis.DataSet();
  function labelGraph() {
    let positions = document.getElementsByClassName('position');
    for (let i=0; i<positions.length; i++) {
      positions[i].textContent = (index+1) + '/' + keys.length;
    }
  }
  function draw() {
    let test = graphs[keys[index]];
    network.unselectAll();
    labelGraph();
    // update graph coloring
    let af = new ArgumentFramework(test);
    let grd = new GroundedReasoner(af).extensions()[0];
    //console.log(keys[index], ' - accepted: ', grd.extensions()[0]);
    for (node in test) {
      nodes.update({id: node, label: String.fromCharCode('A'.charCodeAt(0) + parseInt(node)), border: 'grey', color: {background: (grd.indexOf(node)>-1?'yellow':'red'), border: 'grey'}});
      // remove unneeded attackers
      edges.get({filter: function(item){ return (item.to==node) }}).forEach(function(existing) {
        if (test[node].indexOf(existing.from)==-1) {
          edges.remove(existing.id);
        }
      });
      // add missing attackers
      test[node].forEach(function(attacker) {
        existing = edges.get({filter:function(item){ return (item.to==node && item.from==attacker) }});
        if (existing.length==0) {
          edges.add({to: node, from: attacker, arrows: 'to',color:'grey'});
        }
      });
      for (node in nodes.get()) {
        if (!test.hasOwnProperty(node)) {
          nodes.remove(node);
        }
      }
    }
  }
  function up() {
    if (index<(keys.length-1)) {
      index++;
    } else {
      index=0;
    }
    draw();
  }
  function down() {
    if (index>0) {
      index--;
    } else {
      index=keys.length-1;
    }
    draw();
  }
  let container = document.getElementById('mynetwork');
  let options = {};
  let network = new vis.Network(container, {nodes: nodes, edges: edges}, options);
  draw();
</script>

</body>
</html>
