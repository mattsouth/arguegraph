<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Arguegraph :: Simple<span class="hidden-xs"> graphs</span></title>

  <script type="text/javascript" src="js/vis.min.js"></script>
  <script type="text/javascript" src="js/graphs.js"></script>
  <script type="text/javascript" src="js/arguegraph.js"></script>
  <link href="css/vis.min.css" rel="stylesheet" type="text/css" />

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <style type="text/css">
    #mynetwork {
      height: 250px;
      border: 1px solid lightgray;
    }

    @media (min-width: 768px) {
      #mynetwork {
        height: 400px;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="row">
    <h2 class="col-sm-8 hidden-xs">Arguegraph :: Simple graphs</h2>
    <h2 class="col-sm-8 visible-xs-block">Arguegraph :: Simple</h2>
    <h2 class="col-sm-4 hidden-xs">
      <div class="pull-right">
        <a class="btn btn-default" href="#" onclick="javascript:down()"> &lt; </a>
        <span class="position"></span>
        <a class="btn btn-default" href="#" onclick="javascript:up()"> &gt; </a>
      </div>
    </h2>
    <h3 class="col-sm-4 visible-xs-block">
      <div>
        <a class="btn btn-default" href="#" onclick="javascript:down()"> &lt; </a>
        <span class="position"></span>
        <a class="btn btn-default" href="#" onclick="javascript:up()"> &gt; </a>
      </div>
    </h3>
  </div>
  <div class="row">
    <div class="col-xs-12">
      <p>
        <span class="hidden-xs">A directed graph can be used to represent an adversarial argument
        framework where nodes are arguments and edges are attacks between
        arguments. The arguegraph javascript library allows you to calculate
        the sets of arguments that defend themselves using different algorithms,
        otherwise known as semantics. </span>This demo allows you to view the results
        of different semantics for all the distinct directed graphs with up to
        three nodes.
      </p>
    </div>
  </div>
  <div class="row">
    <div class="col-xs-12">
      <div id="mynetwork"></div>
    </div>
  </div>
  <div class="row">
    <div class="col-xs-6">
      <select id="semantics-options">
        <option value="grounded">Grounded Semantics</option>
        <option value="preferred">Preferred Semantics</option>
      </select>
    </div>
    <div class="col-xs-6" id="extensions">
      <div class="pull-right">
        <a class="btn btn-default" href="#" onclick="javascript:extdown()"> &lt; </a>
        <span id="extension"></span>
        <a class="btn btn-default" href="#" onclick="javascript:extup()"> &gt; </a>
      </div>
    </div>
  </div>
  <div class="row">
    <div class="col-xs-12">
      <p id="semantics-description"></p>
    </div>
  </div>
</div>
<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script type="text/javascript">
  let keys = Object.keys(graphs);
  let index = 0;
  let nodes = new vis.DataSet();
  let edges = new vis.DataSet();
  let semantics = {
    grounded: {
      description: 'Grounded Semantics are the most sceptical.  Nodes/arguments are in the grounded extension if they are unattacked or defended by an argument that is already in the ground extension. For any network there is only ever one ground extension. Yellow nodes are accepted arguments, i.e. can be found in the grounded extension. Red nodes are not.',
      reasoner: 'GroundedReasoner',
      multi: false
    },
    preferred: {
      description: 'Preferred semantics are the most credulous.  Nodes/arguments are in a preferred extension if they can defend themselves and the extension fills as much of the argument framework as it can.  There can be more than one extension - try stepping through them all! Yellow nodes are in the selected extension. Red nodes are not.',
      reasoner: 'PreferredReasoner',
      multi: true
    }
  };
  let semantics_selected = null;
  let extensions = null;
  let extension_index = -1;
  // update current index in the list of available graphs
  function showIndex() {
    let positions = document.getElementsByClassName('position');
    for (let i=0; i<positions.length; i++) {
      positions[i].textContent = (index+1) + '/' + keys.length;
    }
  }
  function showExtensionIndex() {
    document.getElementById('extension').textContent = (extension_index+1) + '/' + extensions.length;
  }
  function selectSemantics(choice) {
    semantics_selected = choice;
    extension_index=0;
    $('#semantics-description').text(semantics[choice].description);
    if (semantics[choice].multi) {
      $('#extensions').removeClass('hidden');
    } else {
      $('#extensions').addClass('hidden');
    }
    draw();
  }
  function draw() {
    let test = graphs[keys[index]];
    network.unselectAll();
    showIndex();
    // update graph coloring
    let af = new ArgumentFramework(test);
    let reasoner = new window[semantics[semantics_selected].reasoner](af);
    extensions = reasoner.extensions();
    extension_index = 0;
    let extension = extensions[extension_index];
    showExtensionIndex();
    for (node in test) {
      nodes.update({id: node, label: String.fromCharCode('A'.charCodeAt(0) + parseInt(node)), border: 'grey', color: {background: (extension.indexOf(node)>-1?'yellow':'red'), border: 'grey'}});
      // remove unneeded attackers
      edges.get({filter: function(item){ return (item.to==node) }}).forEach(function(existing) {
        if (test[node].indexOf(existing.from)==-1) {
          edges.remove(existing.id);
        }
      });
      // add missing attackers
      test[node].forEach(function(attacker) {
        existing = edges.get({filter:function(item){ return (item.to==node && item.from==attacker) }});
        if (existing.length==0) {
          edges.add({to: node, from: attacker, arrows: 'to',color:'grey'});
        }
      });
      for (node in nodes.get()) {
        if (!test.hasOwnProperty(node)) {
          nodes.remove(node);
        }
      }
    }
  }
  // a lightweight version of draw() for when the selected extension changes (but the graph remains the same)
  function update() {
    let test = graphs[keys[index]];
    network.unselectAll();
    let extension = extensions[extension_index];
    showExtensionIndex();
    for (node in test) {
      nodes.update({id: node, label: String.fromCharCode('A'.charCodeAt(0) + parseInt(node)), border: 'grey', color: {background: (extension.indexOf(node)>-1?'yellow':'red'), border: 'grey'}});
    }
  }
  function up() {
    if (index<(keys.length-1)) {
      index++;
    } else {
      index=0;
    }
    draw();
  }
  function down() {
    if (index>0) {
      index--;
    } else {
      index=keys.length-1;
    }
    draw();
  }
  function extup() {
    if (extension_index<(extensions.length-1)) {
      extension_index++;
    } else {
      extension_index=0;
    }
    update();
  }
  function extdown() {
    if (extension_index>0) {
      extension_index--;
    } else {
      extension_index=extensions.length-1;
    }
    update();
  }
  let container = document.getElementById('mynetwork');
  let options = {};
  let network = new vis.Network(container, {nodes: nodes, edges: edges}, options);
  document.getElementById('semantics-options').onchange=function(event) {
    selectSemantics(event.target.value);
  };
  $('#semantics-options').val('grounded').change();
  draw();
</script>

</body>
</html>
